import assert from 'node:assert'
import { type WriteStream, createWriteStream } from 'node:fs'
import ts from 'typescript'

export const typescriptOptions: ts.CompilerOptions = {
  target: ts.ScriptTarget.ES2022,
  module: ts.ModuleKind.Node16,
  moduleResolution: ts.ModuleResolutionKind.Node16,
  skipLibCheck: true,
  skipDefaultLibCheck: true,
  strict: true,
  noEmit: true,
}

export const autoGeneratedNote = '// <auto-generated>\n'

export function generateNewFile(fileName: string, outFile: string) {
  const program = ts.createProgram([fileName], typescriptOptions)

  // TODO: move the diagnostics to a unit test. Here they take 4/5 seconds
  // Check if typescript is producing type errors for the program
  const emitResult = program.emit()
  const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics)

  allDiagnostics.forEach((diagnostic) => {
    if (!diagnostic.file || !diagnostic.start) {
      console.log(ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n'))
      return
    }

    const { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start)
    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')
    console.log(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`)
  })

  // The type checker will give us find more about symbols
  const checker = program.getTypeChecker()
  const sourceFile = program.getSourceFile(fileName)

  if (!sourceFile) {
    throw new Error('Cannot process a undefined file')
  }

  const stream = createWriteStream(outFile, 'utf-8')
  stream.write(autoGeneratedNote)

  ts.forEachChild(sourceFile, (node) => processChild(stream, checker, node))
}

function processChild(writeStream: WriteStream, checker: ts.TypeChecker, node: ts.Node): void {
  if (ts.isImportDeclaration(node)) {
    let importText = node.getFullText().trim()

    // We manually add the newline afterwards, so we need to remove it from here
    if (importText.startsWith('\n')) {
      importText = importText.substring(1)
    }

    writeStream.write(importText)
    writeStream.write('\n')

    return
  }

  if (ts.isInterfaceDeclaration(node)) {
    const symbol = checker.getSymbolAtLocation(node.name)
    if (!symbol) return

    assert(symbol.members)

    // Get the general information about the symbol and it's members
    const members = Array.from(symbol.members.values()).map(getMemberInformation.bind(null, checker))

    writeStream.write('\n')

    writeJSDoc(writeStream, symbol.getDocumentationComment(checker), symbol.getJsDocTags(checker))

    writeStream.write(`export interface ${symbol.getName()} {\n`)

    // Generate the interface in the output file
    for (const memberMetadata of members) {
      writeJSDoc(writeStream, memberMetadata.documentation, memberMetadata.jsDoc, '  ')

      const isOptionalQuestionMark = memberMetadata.isOptional ? '?' : ''

      writeStream.write(`  ${memberMetadata.name}${isOptionalQuestionMark}: ${memberMetadata.type}\n`)
    }

    writeStream.write('}\n')
  }
}

function getMemberInformation(checker: ts.TypeChecker, member: ts.Symbol): TypeInformation {
  const valueDeclaration = member.valueDeclaration
  assert(valueDeclaration)

  const valueDeclarationChildren = valueDeclaration.getChildren()
  const typeNode = valueDeclarationChildren.find((x) => ts.isTypeNode(x))
  assert(typeNode)

  // Since we are getting the type directly from the sourceFile it may have a trailing space, so we remove them
  const typeText = typeNode.getFullText().trim()

  return {
    name: member.getName(),
    type: typeText,
    isOptional: (member.getFlags() & ts.SymbolFlags.Optional) === ts.SymbolFlags.Optional,
    documentation: member.getDocumentationComment(checker),
    jsDoc: member.getJsDocTags(checker),
  }
}

function writeJSDoc(stream: WriteStream, docs: ts.SymbolDisplayPart[], jsDocTags: ts.JSDocTagInfo[], ident = ''): void {
  const withDocs = docs.length > 0
  const withJSdoc = jsDocTags.length > 0

  if (!withDocs && !withJSdoc) return

  stream.write(`${ident}/**`)

  if (withDocs && withJSdoc) {
    stream.write(`\n${ident} *`)
  }

  if (withDocs) {
    writeSymbolDisplayParts(stream, docs, ident)
  }

  for (const jsDoc of jsDocTags) {
    if (withDocs) {
      stream.write(`\n${ident} *`)
    }

    stream.write(`\n${ident} *`)
    stream.write(` @${jsDoc.name}\n${ident} *`)

    if (jsDoc.text) {
      writeSymbolDisplayParts(stream, jsDoc.text, ident)
    }
  }

  if (withJSdoc) {
    stream.write(`\n${ident}`)
  }

  stream.write(' */\n')
}

function writeSymbolDisplayParts(stream: WriteStream, documentation: ts.SymbolDisplayPart[], ident: string): void {
  const docs = documentation.reduce((acc, cur) => `${acc}${cur.kind === 'linkText' ? ' | ' : ''}${cur.text}`, '')
  const splitted = docs.split('\n')

  stream.write(' ')
  stream.write(splitted[0])

  for (const text of splitted.slice(1)) {
    stream.write(`\n${ident} * `)
    stream.write(text)
  }
}

interface TypeInformation {
  name: string
  documentation: ts.SymbolDisplayPart[]
  jsDoc: ts.JSDocTagInfo[]
  type: string
  isOptional: boolean
}
