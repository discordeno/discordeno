import assert from 'node:assert'
import { type WriteStream, createWriteStream } from 'node:fs'
import ts from 'typescript'
import { DesiredProprietiesBehavior, desiredProprietiesBehavior, isProprietyDesired } from './config.js'
import { writeInterfaceMember, writeJSDoc } from './emitter.js'

export const typescriptOptions: ts.CompilerOptions = {
  target: ts.ScriptTarget.ES2022,
  module: ts.ModuleKind.Node16,
  moduleResolution: ts.ModuleResolutionKind.Node16,
  skipLibCheck: true,
  skipDefaultLibCheck: true,
  strict: true,
  noEmit: true,
}

export const autoGeneratedNote = '// <auto-generated>\n'

export function generateNewFile(fileName: string, outFile: string) {
  const program = ts.createProgram([fileName], typescriptOptions)

  // The type checker will give us find more about symbols
  const checker = program.getTypeChecker()
  const sourceFile = program.getSourceFile(fileName)

  if (!sourceFile) {
    throw new Error('Cannot process a undefined file')
  }

  const stream = createWriteStream(outFile, 'utf-8')
  stream.write(autoGeneratedNote)

  ts.forEachChild(sourceFile, (node) => processChild(stream, checker, node))
}

function processChild(writeStream: WriteStream, checker: ts.TypeChecker, node: ts.Node): void {
  if (ts.isImportDeclaration(node)) {
    processImportNode(node, writeStream)
    return
  }

  if (ts.isInterfaceDeclaration(node)) {
    processInterfaceDeclarationNode(node, checker, writeStream)
    return
  }
}

function processInterfaceDeclarationNode(node: ts.InterfaceDeclaration, checker: ts.TypeChecker, writeStream: WriteStream) {
  const symbol = checker.getSymbolAtLocation(node.name)
  if (!symbol) return

  assert(symbol.members)

  const interfaceName = symbol.getName()

  writeStream.write('\n')
  writeJSDoc(writeStream, symbol.getDocumentationComment(checker), symbol.getJsDocTags(checker))
  writeStream.write(`export interface ${interfaceName} {\n`)

  // Generate the interface in the output file
  for (const member of symbol.members.values()) {
    const memberName = member.getName()
    const valueDeclaration = member.valueDeclaration
    assert(valueDeclaration)

    const valueDeclarationChildren = valueDeclaration.getChildren()
    const typeNode = valueDeclarationChildren.find((x) => ts.isTypeNode(x))
    assert(typeNode)

    // Since we are getting the type directly from the sourceFile it may have a trailing space, so we remove them
    const typeText = typeNode.getFullText().trim()
    const jsDoc = member.getJsDocTags(checker)
    const docs = member.getDocumentationComment(checker)
    const isOptional = Boolean(member.getFlags() & ts.SymbolFlags.Optional)

    if (isProprietyDesired(interfaceName, memberName)) {
      writeJSDoc(writeStream, docs, jsDoc, '  ')
      writeInterfaceMember(writeStream, memberName, typeText, isOptional)

      continue
    }

    // The property is undesired
    handleUndesiredProperty(writeStream, docs, jsDoc, memberName, typeText, isOptional)
  }

  writeStream.write('}\n')
}

function processImportNode(node: ts.ImportDeclaration, writeStream: WriteStream) {
  let importText = node.getFullText().trim()

  // We manually add the newline afterwards, so we need to remove it from here
  if (importText.startsWith('\n')) {
    importText = importText.substring(1)
  }

  writeStream.write(importText)
  writeStream.write('\n')
}

function handleUndesiredProperty(
  stream: WriteStream,
  docs: ts.SymbolDisplayPart[],
  jsDoc: ts.JSDocTagInfo[],
  memberName: string,
  typeText: string,
  isOptional: boolean,
) {
  if (desiredProprietiesBehavior === DesiredProprietiesBehavior.Remove) return

  jsDoc.push({
    name: 'remarks',
    text: [
      {
        kind: 'text',
        text: `This property is not desired according to your Desired Properties configuration.\n\nOriginal type: ${typeText}`,
      },
    ],
  })

  writeJSDoc(stream, docs, jsDoc, '  ')
  writeInterfaceMember(stream, memberName, 'never', isOptional)
}
