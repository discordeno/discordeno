import assert from 'node:assert'
import { type WriteStream, createWriteStream } from 'node:fs'
import ts from 'typescript'

export const typescriptOptions: ts.CompilerOptions = {
  target: ts.ScriptTarget.ES2022,
  module: ts.ModuleKind.Node16,
  moduleResolution: ts.ModuleResolutionKind.Node16,
  skipLibCheck: true,
  skipDefaultLibCheck: true,
  strict: true,
  noEmit: true,
}

export const autoGeneratedNote = '// <auto-generated>\n'

export function generateNewFile(fileName: string, outFile: string) {
  const program = ts.createProgram([fileName], typescriptOptions)

  // The type checker will give us find more about symbols
  const checker = program.getTypeChecker()
  const sourceFile = program.getSourceFile(fileName)

  if (!sourceFile) {
    throw new Error('Cannot process a undefined file')
  }

  const stream = createWriteStream(outFile, 'utf-8')
  stream.write(autoGeneratedNote)

  ts.forEachChild(sourceFile, (node) => processChild(stream, checker, node))
}

function processChild(writeStream: WriteStream, checker: ts.TypeChecker, node: ts.Node): void {
  if (ts.isImportDeclaration(node)) {
    let importText = node.getFullText().trim()

    // We manually add the newline afterwards, so we need to remove it from here
    if (importText.startsWith('\n')) {
      importText = importText.substring(1)
    }

    writeStream.write(importText)
    writeStream.write('\n')

    return
  }

  if (ts.isInterfaceDeclaration(node)) {
    const symbol = checker.getSymbolAtLocation(node.name)
    if (!symbol) return

    assert(symbol.members)

    writeStream.write('\n')

    writeJSDoc(writeStream, symbol.getDocumentationComment(checker), symbol.getJsDocTags(checker))

    writeStream.write(`export interface ${symbol.getName()} {\n`)

    // Generate the interface in the output file
    for (const [, member] of symbol.members) {
      const valueDeclaration = member.valueDeclaration
      assert(valueDeclaration)

      const valueDeclarationChildren = valueDeclaration.getChildren()
      const typeNode = valueDeclarationChildren.find((x) => ts.isTypeNode(x))
      assert(typeNode)

      // Since we are getting the type directly from the sourceFile it may have a trailing space, so we remove them
      const typeText = typeNode.getFullText().trim()

      writeJSDoc(writeStream, member.getDocumentationComment(checker), member.getJsDocTags(checker), '  ')

      const isOptionalQuestionMark = member.getFlags() & ts.SymbolFlags.Optional ? '?' : ''

      writeStream.write(`  ${member.getName()}${isOptionalQuestionMark}: ${typeText}\n`)
    }

    writeStream.write('}\n')
  }
}

function writeJSDoc(stream: WriteStream, docs: ts.SymbolDisplayPart[], jsDocTags: ts.JSDocTagInfo[], ident = ''): void {
  const withDocs = docs.length > 0
  const withJSdoc = jsDocTags.length > 0

  if (!withDocs && !withJSdoc) return

  stream.write(`${ident}/**`)

  if (withDocs && withJSdoc) {
    stream.write(`\n${ident} *`)
  }

  if (withDocs) {
    writeSymbolDisplayParts(stream, docs, ident)
  }

  for (const jsDoc of jsDocTags) {
    if (withDocs) {
      stream.write(`\n${ident} *`)
    }

    stream.write(`\n${ident} *`)
    stream.write(` @${jsDoc.name}\n${ident} *`)

    if (jsDoc.text) {
      writeSymbolDisplayParts(stream, jsDoc.text, ident)
    }
  }

  if (withJSdoc) {
    stream.write(`\n${ident}`)
  }

  stream.write(' */\n')
}

function writeSymbolDisplayParts(stream: WriteStream, documentation: ts.SymbolDisplayPart[], ident: string): void {
  const docs = documentation.reduce((acc, cur) => `${acc}${cur.kind === 'linkText' ? ' | ' : ''}${cur.text}`, '')
  const splitted = docs.split('\n')

  stream.write(' ')
  stream.write(splitted[0])

  for (const text of splitted.slice(1)) {
    stream.write(`\n${ident} * `)
    stream.write(text)
  }
}
