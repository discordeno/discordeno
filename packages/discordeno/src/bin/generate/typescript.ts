import assert from 'node:assert'
import { type WriteStream, createWriteStream } from 'node:fs'
import ts from 'typescript'
import { DesiredProprietiesBehavior, desiredProprietiesBehavior, isProprietyDesired } from './config.js'

export const typescriptOptions: ts.CompilerOptions = {
  target: ts.ScriptTarget.ES2022,
  module: ts.ModuleKind.Node16,
  moduleResolution: ts.ModuleResolutionKind.Node16,
  skipLibCheck: true,
  skipDefaultLibCheck: true,
  strict: true,
  noEmit: true,
}

export const autoGeneratedNote = '// <auto-generated>\n'

export function generateNewFile(fileName: string, outFile: string) {
  const program = ts.createProgram([fileName], typescriptOptions)

  // The type checker will give us find more about symbols
  const checker = program.getTypeChecker()
  const sourceFile = program.getSourceFile(fileName)

  if (!sourceFile) {
    throw new Error('Cannot process a undefined file')
  }

  const stream = createWriteStream(outFile, 'utf-8')
  stream.write(autoGeneratedNote)

  ts.forEachChild(sourceFile, (node) => processChild(stream, checker, node))
}

function processChild(writeStream: WriteStream, checker: ts.TypeChecker, node: ts.Node): void {
  if (ts.isImportDeclaration(node)) {
    processImportNode(node, writeStream)
    return
  }

  if (ts.isInterfaceDeclaration(node)) {
    processInterfaceDeclarationNode(node, checker, writeStream)
    return
  }
}

function processInterfaceDeclarationNode(node: ts.InterfaceDeclaration, checker: ts.TypeChecker, writeStream: WriteStream) {
  const symbol = checker.getSymbolAtLocation(node.name)
  if (!symbol) return

  assert(symbol.members)

  writeStream.write('\n')

  writeJSDoc(writeStream, symbol.getDocumentationComment(checker), symbol.getJsDocTags(checker))

  const interfaceName = symbol.getName()

  writeStream.write(`export interface ${interfaceName} {\n`)

  // Generate the interface in the output file
  for (const [, member] of symbol.members) {
    const memberName = member.getName()
    const isDesired = isProprietyDesired(interfaceName, memberName)

    const valueDeclaration = member.valueDeclaration
    assert(valueDeclaration)

    const valueDeclarationChildren = valueDeclaration.getChildren()
    const typeNode = valueDeclarationChildren.find((x) => ts.isTypeNode(x))
    assert(typeNode)

    // Since we are getting the type directly from the sourceFile it may have a trailing space, so we remove them
    let typeText = typeNode.getFullText().trim()
    const jsDoc = member.getJsDocTags(checker)
    const isOptionalQuestionMark = member.getFlags() & ts.SymbolFlags.Optional ? '?' : ''

    if (!isDesired) {
      switch (desiredProprietiesBehavior) {
        case DesiredProprietiesBehavior.Remove: {
          continue
        }
        case DesiredProprietiesBehavior.TypeAsNever: {
          jsDoc.push({
            name: 'remarks',
            text: [
              {
                kind: 'text',
                text: `This property is not desired according to your Desired Properties configuration.\n\nOriginal type: ${typeText}`,
              },
            ],
          })

          typeText = 'never'

          break
        }
      }
    }

    writeJSDoc(writeStream, member.getDocumentationComment(checker), jsDoc, '  ')

    writeStream.write(`  ${memberName}${isOptionalQuestionMark}: ${typeText}\n`)
  }

  writeStream.write('}\n')
}

function processImportNode(node: ts.ImportDeclaration, writeStream: WriteStream) {
  let importText = node.getFullText().trim()

  // We manually add the newline afterwards, so we need to remove it from here
  if (importText.startsWith('\n')) {
    importText = importText.substring(1)
  }

  writeStream.write(importText)
  writeStream.write('\n')
}

function writeJSDoc(stream: WriteStream, docs: ts.SymbolDisplayPart[], jsDocTags: ts.JSDocTagInfo[], ident = ''): void {
  const withDocs = docs.length > 0
  const withJSdoc = jsDocTags.length > 0

  if (!withDocs && !withJSdoc) return

  stream.write(`${ident}/**`)

  if (withDocs && withJSdoc) {
    stream.write(`\n${ident} *`)
  }

  if (withDocs) {
    writeSymbolDisplayParts(stream, docs, ident)
  }

  for (const jsDoc of jsDocTags) {
    if (withDocs) {
      stream.write(`\n${ident} *`)
    }

    stream.write(`\n${ident} *`)
    stream.write(` @${jsDoc.name}\n${ident} *`)

    if (jsDoc.text) {
      writeSymbolDisplayParts(stream, jsDoc.text, ident)
    }
  }

  if (withJSdoc) {
    stream.write(`\n${ident}`)
  }

  stream.write(' */\n')
}

function writeSymbolDisplayParts(stream: WriteStream, documentation: ts.SymbolDisplayPart[], ident: string): void {
  const docs = documentation.reduce((acc, cur) => `${acc}${cur.kind === 'linkText' ? ' | ' : ''}${cur.text}`, '')
  const splitted = docs.split('\n')

  stream.write(' ')
  stream.write(splitted[0])

  for (const text of splitted.slice(1)) {
    stream.write(`\n${ident} * `)
    stream.write(text)
  }
}
