import assert from 'node:assert'
import { type WriteStream, createWriteStream } from 'node:fs'
import ts from 'typescript'
import { DesiredPropertiesBehavior, type DiscordenoConfig, typescriptOptions } from '../config.js'
import { getPropertyDependencies, isPropertyDesired } from './desiredProperty.js'
import { writeInterfaceMember, writeJSDoc } from './emitter.js'

export const autoGeneratedNote = '// <auto-generated>\n'

export function generateNewFile(config: DiscordenoConfig, fileName: string, outFile: string) {
  const program = ts.createProgram([fileName], typescriptOptions)

  // The type checker will give us find more about symbols
  const checker = program.getTypeChecker()
  const sourceFile = program.getSourceFile(fileName)

  if (!sourceFile) {
    throw new Error('Cannot process a undefined file')
  }

  const stream = createWriteStream(outFile, 'utf-8')
  stream.write(autoGeneratedNote)

  ts.forEachChild(sourceFile, (node) => processChild(stream, config, checker, node))
}

function processChild(writeStream: WriteStream, config: DiscordenoConfig, checker: ts.TypeChecker, node: ts.Node): void {
  if (ts.isImportDeclaration(node)) {
    processImportNode(node, writeStream)
    return
  }

  if (ts.isInterfaceDeclaration(node)) {
    processInterfaceDeclarationNode(node, config, checker, writeStream)
    return
  }
}

function processInterfaceDeclarationNode(node: ts.InterfaceDeclaration, config: DiscordenoConfig, checker: ts.TypeChecker, writeStream: WriteStream) {
  const symbol = checker.getSymbolAtLocation(node.name)
  if (!symbol) return

  assert(symbol.members)

  const interfaceName = symbol.getName()

  writeStream.write('\n')
  writeJSDoc(writeStream, symbol.getDocumentationComment(checker), symbol.getJsDocTags(checker))
  writeStream.write(`export interface ${interfaceName} {\n`)

  // Generate the interface in the output file
  for (const member of symbol.members.values()) {
    const memberName = member.getName()
    const valueDeclaration = member.valueDeclaration
    assert(valueDeclaration)

    const valueDeclarationChildren = valueDeclaration.getChildren()
    const typeNode = valueDeclarationChildren.find((x) => ts.isTypeNode(x))
    assert(typeNode)

    // Since we are getting the type directly from the sourceFile it may have a trailing space, so we remove them
    const typeText = typeNode.getFullText().trim()
    const jsDoc = member.getJsDocTags(checker)
    const docs = member.getDocumentationComment(checker)
    const isOptional = !!(member.getFlags() & ts.SymbolFlags.Optional)
    const isInternal = !!jsDoc.find((x) => x.name === 'internal')

    // If the propriety is internal then we don't want to apply the desired propriety logic to it
    if (isInternal || isPropertyDesired(config, interfaceName, memberName)) {
      writeJSDoc(writeStream, docs, jsDoc, '  ')
      writeInterfaceMember(writeStream, memberName, typeText, isOptional)

      continue
    }

    // The property is undesired
    handleUndesiredProperty(writeStream, config, docs, jsDoc, interfaceName, memberName, typeText, isOptional)
  }

  writeStream.write('}\n')
}

function processImportNode(node: ts.ImportDeclaration, writeStream: WriteStream) {
  let importText = node.getFullText().trim()

  // We manually add the newline afterwards, so we need to remove it from here
  if (importText.startsWith('\n')) {
    importText = importText.substring(1)
  }

  writeStream.write(importText)
  writeStream.write('\n')
}

function handleUndesiredProperty(
  stream: WriteStream,
  config: DiscordenoConfig,
  docs: ts.SymbolDisplayPart[],
  jsDoc: ts.JSDocTagInfo[],
  interfaceName: string,
  memberName: string,
  typeText: string,
  isOptional: boolean,
) {
  if (config.desiredProperties.behavior === DesiredPropertiesBehavior.Remove) return

  const dependencies = getPropertyDependencies(interfaceName, memberName)

  const additionalJsDocTag: ts.JSDocTagInfo = {
    name: 'remarks',
    text: [
      {
        kind: 'text',
        text: `This property is not desired according to your Desired Properties configuration.\n\nOriginal type: ${typeText}${dependencies ? `\n\nThis value requires other values to be enabled, those are: ${dependencies.join(', ')}` : ''}`,
      },
    ],
  }

  jsDoc.push(additionalJsDocTag)

  writeJSDoc(stream, docs, jsDoc, '  ')
  writeInterfaceMember(stream, memberName, 'never', isOptional)
}
